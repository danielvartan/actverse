## Match original epochs to new epochs
output$interval <- NA
for (i in seq_len(nrow(output))) {
output$interval[i] <-
which(output[[timestamp]][i] %within% intervals$interval)
pb$tick()
}
# Select data --------------------
if (!(is.null(variable))) {
output <- data %>%
dplyr::select(!!as.symbol(timestamp), !!as.symbol(variable))
} else {
output <- data
}
# Set epoch values --------------------
epoch <- epoch(data)
if (identical(new_epoch, epoch)) {
return(output)
}
if (new_epoch < epoch && !(method %in% c("divide"))) {
stop("method is not a valid. See documentation.", call. = FALSE)
}
if (new_epoch < epoch && !(epoch %% new_epoch == 0)) {
stop(paste("new_epoch value is not a divisor of the original epoch.",
"See documentation."), call. = FALSE)
}
epoch_count <- as.numeric(lubridate::as.duration(
dplyr::last(data[[timestamp]]) -
dplyr::first(data[[timestamp]]))) / epoch
if (!(length(data[[timestamp]]) < epoch_count * 1.01 &&
length(data[[timestamp]]) > epoch_count * 0.9)) {
stop(paste("Timestamp length don't match with epoch count.",
"Some of your data appears to be missing", call. = FALSE))
}
new_epoch_count <- ceiling(epoch_count * (epoch / new_epoch))
# Change epoch length --------------------
## Set intervals
intervals <- dplyr::tibble(
onset = seq(data[[timestamp]][1], by = new_epoch,
length.out = new_epoch_count),
offset = seq(data[[timestamp]][1] + seconds(new_epoch - 1),
by = new_epoch,
length.out = new_epoch_count)) %>%
dplyr::mutate(interval = lubridate::interval(start = .data$onset,
end = .data$offset))
## Add new cases (if (new_epoch < epoch))
if (new_epoch < epoch) {
subset <- tibble(timestamp = intervals$onset)
old_cases <- subset[seq(from = 1,
to = new_epoch_count,
by = epoch / new_epoch), ]
new_cases <- anti_join(subset, old_cases, by = timestamp)
output <- full_join(output, new_cases, by = timestamp) %>%
arrange(timestamp)
}
## Set progress bar
pb <- progress::progress_bar$new(
format = "[:bar] :current/:total (:percent) (:eta) (:elapsedfull)",
total = nrow(output),
clear = FALSE,
show_after = 0)
pb$message(paste("Matching original epochs to new epochs.",
"This may take a while, don't be alarmed."))
pb$tick(0)
pb <- progress::progress_bar$new(
format = "[:bar] :current/:total (:percent) (:eta) (:elapsedfull)",
total = nrow(output),
clear = FALSE,
show_after = 0)
pb$message(paste("Matching original epochs to new epochs.",
"This may take a while, don't be alarmed."))
pb$tick(0)
## Match original epochs to new epochs
output$interval <- NA
for (i in seq_len(nrow(output))) {
output$interval[i] <-
which(output[[timestamp]][i] %within% intervals$interval)
pb$tick()
}
View(output)
bkp <- output
bkp2 <- output
output <- output %>%
dplyr::group_by(interval) %>%
dplyr::summarise(
dplyr::across(!!as.symbol(variable), get(method))) %>%
dplyr::mutate(!!as.symbol(timestamp) := intervals$offset) %>%
dplyr::select(-interval) %>%
dplyr::relocate(!!as.symbol(timestamp))
divide <- function(x) {
sum(x) / n()
}
same <- function(x) {
(sum(x) * (epoch / new_epoch)) / n()
}
output <- bkp
output <- output %>%
dplyr::group_by(interval) %>%
dplyr::summarise(
dplyr::across(!!as.symbol(variable), get(method))) %>%
dplyr::mutate(!!as.symbol(timestamp) := intervals$offset) %>%
dplyr::select(-interval) %>%
dplyr::relocate(!!as.symbol(timestamp))
output <- bkp
output <- output %>%
dplyr::group_by(interval) %>%
dplyr::summarise(
dplyr::across(!!as.symbol(variable), get(method)))
View(intervals)
View(bkp)
test <- bkp
test$n <- seq(nrow(test))
View(test)
last(intervals$offset)
last(data$timestamp)
View(bkp)
?n
epoch / new_epoch
test_log <- load_and_tidy()
test_log <- load_and_tidy()
?use_data
use_data(test_log)
use_data(test_log, overwrite = TRUE)
load_all()
rm(list = c("epoch"))
load_all()
x <- test_log
rm(x)
rm(test_log)
data <- test_log
rm(list = ls())
data <- test_logo
data <- test_log
new_epoch <- 30
method <- "divide"
variable <- "pim"
# Check arguments --------------------
if (!(is.data.frame(data))) {
stop("data is not a data frame", call. = FALSE)
}
check <- c("divide", "same", "first", "last", "sum", "mean", "median")
if (!(method %in% check)) {
stop("method is not a valid. See documentation.", call. = FALSE)
}
check <- c("divide", "same", "sum", "mean", "median")
if (!(is.null(variable)) && !(is.numeric(variable)) &&
!(method %in% check)) {
stop(paste(variable, "is not numeric. The method selected only works",
"with numeric variables."), call. = FALSE)
}
if (is.null(variable) && !(is_tidy(data))) {
stop(paste("data is not tidy"), call. = FALSE)
}
for (i in c("timestamp", "variable")) {
if (i == "variable" && is.null(variable)) {
next
}
if (!(get(i) %in% names(data))) {
stop(paste(i, "were not found in data"), call. = FALSE)
}
}
if (!(new_epoch %% 1 == 0)) {
stop(paste("new_epoch must be a integer number"), call. = FALSE)
}
if (length(data[[timestamp]]) < 2) {
stop(paste("timestamp variable length is less than 2"), call. = FALSE)
}
if (any(is.na(data[[timestamp]]))) {
stop(paste("timestamp variable have NAs"), call. = FALSE)
}
if (!(is.data.frame(data))) {
stop("data is not a data frame", call. = FALSE)
}
check <- c("divide", "same", "first", "last", "sum", "mean", "median")
if (!(method %in% check)) {
stop("method is not a valid. See documentation.", call. = FALSE)
}
check <- c("divide", "same", "sum", "mean", "median")
if (!(is.null(variable)) && !(is.numeric(variable)) &&
!(method %in% check)) {
stop(paste(variable, "is not numeric. The method selected only works",
"with numeric variables."), call. = FALSE)
}
if (is.null(variable) && !(is_tidy(data))) {
stop(paste("data is not tidy"), call. = FALSE)
}
for (i in c("timestamp", "variable")) {
if (i == "variable" && is.null(variable)) {
next
}
if (!(get(i) %in% names(data))) {
stop(paste(i, "were not found in data"), call. = FALSE)
}
}
timestamp = "timestamp"
for (i in c("timestamp", "variable")) {
if (i == "variable" && is.null(variable)) {
next
}
if (!(get(i) %in% names(data))) {
stop(paste(i, "were not found in data"), call. = FALSE)
}
}
if (!(new_epoch %% 1 == 0)) {
stop(paste("new_epoch must be a integer number"), call. = FALSE)
}
if (length(data[[timestamp]]) < 2) {
stop(paste("timestamp variable length is less than 2"), call. = FALSE)
}
if (any(is.na(data[[timestamp]]))) {
stop(paste("timestamp variable have NAs"), call. = FALSE)
}
# Select data --------------------
if (!(is.null(variable))) {
output <- data %>%
dplyr::select(!!as.symbol(timestamp), !!as.symbol(variable))
} else {
output <- data
}
epoch <- epoch(data)
if (identical(new_epoch, epoch)) {
return(output)
}
if (new_epoch < epoch && !(method %in% c("divide"))) {
stop("method is not a valid. See documentation.", call. = FALSE)
}
if (new_epoch < epoch && !(epoch %% new_epoch == 0)) {
stop(paste("new_epoch value is not a divisor of the original epoch.",
"See documentation."), call. = FALSE)
}
epoch_count <- as.numeric(lubridate::as.duration(
dplyr::last(data[[timestamp]]) -
dplyr::first(data[[timestamp]]))) / epoch
if (!(length(data[[timestamp]]) < epoch_count * 1.01 &&
length(data[[timestamp]]) > epoch_count * 0.9)) {
stop(paste("Timestamp length don't match with epoch count.",
"Some of your data appears to be missing", call. = FALSE))
}
new_epoch_count <- ceiling(epoch_count * (epoch / new_epoch))
# Set helper functions --------------------
divide <- function(x) {
sum(x) / (epoch / new_epoch)
}
same <- function(x) {
sum(x)
}
intervals <- dplyr::tibble(
onset = seq(data[[timestamp]][1], by = new_epoch,
length.out = new_epoch_count),
offset = seq(data[[timestamp]][1] + seconds(new_epoch - 1),
by = new_epoch,
length.out = new_epoch_count)) %>%
dplyr::mutate(interval = lubridate::interval(start = .data$onset,
end = .data$offset))
View(intervals)
## Set progress bar
pb <- progress::progress_bar$new(
format = "[:bar] :current/:total (:percent) (:eta) (:elapsedfull)",
total = nrow(output),
clear = FALSE,
show_after = 0)
pb$message(paste("Matching original epochs to new epochs.",
"This may take a while, don't be alarmed."))
pb$tick(0)
## Match original epochs to new epochs
output$interval <- NA
for (i in seq_len(nrow(output))) {
output$interval[i] <-
which(output[[timestamp]][i] %within% intervals$interval)
pb$tick()
}
View(output)
bkp <- output
test <- anti_join(output, intervals, by = interval)
test <- anti_join(output, intervals, by = "interval")
names(output)
names(intervals)
test <- anti_join(output, intervals, by = interval)
test <- full_join(output, intervals, by = interval)
test <- full_join(output, intervals, by = "interval")
View(intervals)
intervals <- dplyr::tibble(
onset = seq(data[[timestamp]][1], by = new_epoch,
length.out = new_epoch_count),
offset = seq(data[[timestamp]][1] + seconds(new_epoch - 1),
by = new_epoch,
length.out = new_epoch_count)) %>%
dplyr::mutate(interval = lubridate::interval(start = .data$onset,
end = .data$offset),
n = n())
intervals <- dplyr::tibble(
onset = seq(data[[timestamp]][1], by = new_epoch,
length.out = new_epoch_count),
offset = seq(data[[timestamp]][1] + seconds(new_epoch - 1),
by = new_epoch,
length.out = new_epoch_count)) %>%
dplyr::mutate(interval = lubridate::interval(start = .data$onset,
end = .data$offset),
n = seq(nrow(intervals)))
intervals <- dplyr::tibble(
onset = seq(data[[timestamp]][1], by = new_epoch,
length.out = new_epoch_count),
offset = seq(data[[timestamp]][1] + seconds(new_epoch - 1),
by = new_epoch,
length.out = new_epoch_count)) %>%
dplyr::mutate(interval = lubridate::interval(start = .data$onset,
end = .data$offset),
n = seq(nrow(intervals))) %>%
dplyr::relocate(n))
intervals <- dplyr::tibble(
onset = seq(data[[timestamp]][1], by = new_epoch,
length.out = new_epoch_count),
offset = seq(data[[timestamp]][1] + seconds(new_epoch - 1),
by = new_epoch,
length.out = new_epoch_count)) %>%
dplyr::mutate(interval = lubridate::interval(start = .data$onset,
end = .data$offset),
n = seq(nrow(intervals))) %>%
dplyr::relocate(n)
subset <- tibble(timestamp = intervals$onset, interval = intervals$n)
View(subset)
test <- anti_join(output, subset, by = interval)
est <- anti_join(output, subset, by = "interval")
rm(est)
test <- anti_join(output, subset, by = "interval")
View(test)
test <- anti_join(subset, output, by = "interval")
View(test)
test <- right_join(output, subset, by = "interval")
test <- right_join(output, subset, by = c("interval", timestamp))
test <- right_join(output, subset, by = "interval")
test <- anti_join(subset, output, by = "interval")
test <- anti_join(subset, output, by = "interval") %>%
full_join(output, by = timestamp)
test <- anti_join(subset, output, by = "interval") %>%
full_join(output, by = c("interval", timestamp))
test <- anti_join(subset, output, by = "interval") %>%
full_join(output, by = c("interval", timestamp)) %>%
dplyr::arrange(timestamp)
View(output)
if (new_epoch < epoch) {
subset <- tibble(!!as.symbol(timestamp) := intervals$onset,
interval = intervals$n)
output <- anti_join(subset, output, by = "interval") %>%
full_join(output, by = c("interval", timestamp)) %>%
dplyr::arrange(timestamp)
}
View(output)
output <- output %>%
dplyr::group_by(interval) %>%
dplyr::summarise(
dplyr::across(!!as.symbol(variable), get(method))) %>%
dplyr::mutate(!!as.symbol(timestamp) := intervals$offset) %>%
dplyr::select(-interval) %>%
dplyr::relocate(!!as.symbol(timestamp))
rep(2)
rep(4)
rep(4,2)
?summarise
?group_by
check()
rm(list = ls())
check()
load_all()
?epoch_change
test_log
load_and_tidy()
logName <- test_log
logName <- load_data()
View(logName)
names(logName)
head(test_log)
test_log$timestamp[1]
library(lubridate)
hour(test_log$timestamp[1])
minute(test_log$timestamp[1])
second(test_log$timestamp[1])
date(test_log$timestamp[1])
library(hms)
(test_log$timestamp[1]))
as_hms((test_log$timestamp[1]))
test_log
str(test_log$state)
View(test_log)
load_all()
epoch(test_log)
View(logName)
load_all()
epoch(test_log)
is_tidy(test_log)
model_data()
?ts
ts(1:10, frequency = 4, start = c(1959, 2)
)
class(ts(1:10, frequency = 4, start = c(1959, 2)))
load_all()
library(lubridate)
hours(as.POSIXct("2020-01-01 00:00:00"))
hour(as.POSIXct("2020-01-01 00:00:00"))
hour(as.POSIXct("2020-01-01 01:00:00"))
lubridate::hour(as.POSIXct("2020-01-01 01:00:00"))
utils::head(mtcars)
data <- test_log
data[,timestamp]
timestamp = "timestamp"
col_name = "pim"
data[,timestamp]
x <- data[,timestamp]
View(x)
x <- data[[,timestamp]]
data[[,timestamp]]
library(dplyr)
data[[,timestamp]]
data[[, timestamp]]
data[[timestamp]]
library(dplyr)
valid_data <- select(timestamp, pim)
valid_data <- data %>% select(timestamp, pim)
View(valid_data)
as.Date(data$timestamp[1])
date(data$timestamp[1])
last(timestamp)
last(data$timestamp)
message(paste("M10 was calculated in", duration, "seconds"))
message("fdsadasdasdsa")
npcra_m10(data)
?npcra_10
?npcra_m10
names(test_log)
session_info()
use_testthat()
library(devtools)
use_testthat()
use_testthat()
use_testthat()
stringi::stri_escape_unicode("Téste")
print(stringi::stri_escape_unicode("Téste"))
cat(stringi::stri_escape_unicode("Téste"))
paste(stringi::stri_escape_unicode("Téste")))
paste(stringi::stri_escape_unicode("Téste"))
"T\\u00e9ste"
paste0("T", "\\u00e9", "ste")
?getOption
person(given = "Daniel",
family = "Vartanian",
role = c("aut", "cph", "cre"),
email = "danvartan@gmail.com",
comment = c(ORCID = "0000-0001-7782-759X"))
file.path(R.home("doc"), "KEYWORDS")
load_all()
?epoch_change
document()
load_all()
?epoch_change
sum(F, F, F, T, T)
sum("a")
document()
load_all(\)
load_all()
package?actstudio
document()
package?actstudio
browseVignettes("dplyr")
use_vignette("classification_methods")
load_all(\)
load_all()
search()
.pkgenv$tz
1:10
class(1:10)
mtcars
load_all()
citation("actstudio")
use_build_ignore()
?use_build_ignore
use_code_of_conduct()
use_github_action_check_standard()
document()
usethis::use_readme_rmd()
use_lifecycle_badge("experimental")
usethis::use_pkgdown()
usethis::use_github_action("pkgdown")
use_package_doc()
use_r("npcra")
load_all()
document()
head(test_log)
class(test_log$timestamp)
class(test_log[2])
class(test_log[[2]])
class(test_log$ms)
class(test_log$x_axis)
class(test_log$z_axis)
class(test_log$pim)
class(test_log$pim_n)
class(test_log$state)
class(test_log$event)
head(test_log)
nrow(test_log)
use_pipe()
?use_pipe
use_vignette("actstudio")
use_news_md()
document()
use_pipe(export = FALSE)
use_tibble()
document()
usethis::use_lifecycle()
document()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
